<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ assembly name="%USERPROFILE%\.nuget\packages\microsoft.odata.edm\7.7.0\lib\net45\Microsoft.OData.Edm.dll" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="Microsoft.OData.Edm" #>
<#@ import namespace="Microsoft.OData.Edm.Csdl" #>
<#@ import namespace="System.Collections.Generic" #>
<#+
private IEdmModel model;
private string theNamespace;
private string theFilename;

public void EmitPlantDiagram(string csdl, string filename)
{
	this.model = CsdlReader.Parse(XElement.Parse(csdl).CreateReader());
	if (this.model == null)
	{
		this.WriteLine("Failed to parse the CSDL file.");
	}

	this.theNamespace = this.model.DeclaredNamespaces.First();
	this.theFilename = filename;
#>
@startuml

title API Entity Diagram for namespace <#= this.theNamespace #> in <#= this.theFilename #>


<#+
	this.EmitEntityContainer();
	this.WriteLine("");

	foreach (IEdmEntityType entity in model.SchemaElements.OfType<IEdmEntityType>())
	{
		this.EmitStructuralType(entity, "entity");
		this.EmitNavigationProperties(entity);
		this.EmitInheritance(entity);
		this.WriteLine("");

		// TODO: Add Bound functions and actions in the third vertical bar 
	}

	foreach (IEdmComplexType complex in model.SchemaElements.OfType<IEdmComplexType>())
	{
		this.EmitStructuralType(complex, "complexType");
		this.EmitInheritance(complex);
		this.WriteLine("");
	}

	foreach (IEdmEnumType enumeration in model.SchemaElements.OfType<IEdmEnumType>())
	{
		this.EmitEnumType(enumeration);
		this.WriteLine("");
	}
}

private string GetTypeName(IEdmTypeReference theType)
{
	var name = ExtensionMethods.ShortQualifiedName(theType);
	if (name == null)
	{
		// Collections don't produce a SQN.
		name = ExtensionMethods.FullName(theType);
	}

	if (name.Contains(this.theNamespace))
	{
		name = name.Replace(this.theNamespace + ".", string.Empty);
	}
	return name;
}

private string StripCollection(string name)
{
	const string collectionPrefix = "Collection(";
	if (name.Contains(collectionPrefix))
	{
		name = name.Replace(collectionPrefix, string.Empty);
		name = name.Substring(0, name.Length -1);
	}
	return name;
}

private string StripNamespace(string name)
{
	return name.Replace(this.theNamespace + ".", string.Empty);
}


private string GetTypeName(IEdmType theType)
{
	var typeName = string.Empty;
	if (theType is IEdmComplexType complex)
	{
		typeName =  complex.Name;
	}
	else if (theType is IEdmEntityType entity)
	{
		typeName =  entity.Name;
	}
	else if (theType is IEdmCollectionType collection)
	{
		typeName =  GetTypeName(collection.ElementType);
	}
	else if (theType is IEdmEnumType enumeration)
	{
		typeName =  enumeration.Name;
	}

	return StripNamespace(typeName);
}

private string GetTypeColor(IEdmType theType)
{
	if (theType is IEdmComplexType complex)
	{
		return "#Skyblue";
	}
	else if (theType is IEdmEntityType entity)
	{
		return "#PaleGreen";
	}
	return string.Empty;
}


private void EmitStructuralType(IEdmStructuredType theType, string prototype)
{
	List<string> props = new List<string>();
	if (theType is IEdmEntityType)
	{
		// Add fake id property because everythign is derived from Graph's 'Entity' base type which would clutter the diagram.
		props.Add("+id: String");
	}

	foreach (IEdmStructuralProperty structProp in theType.DeclaredProperties.OfType<IEdmStructuralProperty>())
	{
		var typeName = this.GetTypeName(structProp.Type);
		props.Add($"+{structProp.Name}: {typeName}");
		string basePropType = StripCollection(typeName);
	}
	var isAbstract = theType.IsAbstract ? "abstract " : string.Empty;
#>
<#= isAbstract #>class <#=this.GetTypeName(theType)#> <<<#=prototype#>>> <#=this.GetTypeColor(theType)#> {
<#+ foreach ( var prop in props) { WriteLine(prop); }#>
}
<#+
}

private void EmitEntityContainer()
{
	if (this.model.EntityContainer == null)
	{
		return;
	}

	List<string> members = new List<string>();
	foreach (IEdmSingleton singleton in this.model.EntityContainer.Elements.OfType<IEdmSingleton>())
	{
		var singletonTypeName = GetTypeName(singleton.Type);
		members.Add($"+{singleton.Name}: {singletonTypeName}");
#>
<#=this.model.EntityContainer.Name#> .. "1..1" <#=singletonTypeName#>: <#=singleton.Name#>
<#+
	}

	foreach (IEdmEntitySet entitySet in this.model.EntityContainer.Elements.OfType<IEdmEntitySet>())
	{
		var entitySetTypeName = GetTypeName(entitySet.EntityType());
		members.Add($"+{entitySet.Name}: {entitySetTypeName}");
#>
<#=this.model.EntityContainer.Name#> .. "0..*" <#=StripCollection(entitySetTypeName)#>: <#=entitySet.Name#>
<#+
	}
#>
class <#=this.model.EntityContainer.Name#> <<entityContainer>> #LightPink {
<#+ foreach ( var member in members) { WriteLine(member); }#>
}
<#+
}

private void EmitEnumType(IEdmEnumType theType)
{
#>
enum <#=this.GetTypeName(theType)#> <<enum>> #GoldenRod {
<#+ foreach (IEdmEnumMember member in theType.Members) { WriteLine($"{member.Name}"); }#>
}
<#+
}

private void EmitInheritance(IEdmStructuredType theType)
{
	if (theType.BaseType != null)
	{
#>
<#=GetTypeName(theType.BaseType as IEdmStructuredType)#> <|-- <#=GetTypeName(theType)#>
<#+
	}
}

private void EmitNavigationProperties(IEdmEntityType entity)
{
	foreach (IEdmNavigationProperty navProp in entity.DeclaredProperties.OfType<IEdmNavigationProperty>())
	{
		var target = (navProp.Type as IEdmTypeReference).Definition;
		IEdmEntityType entityTarget;
		var collectionProp = false;
		if (target is IEdmCollectionType coll)
		{
			entityTarget = (coll.ElementType as IEdmTypeReference).Definition as IEdmEntityType;
			collectionProp = true;
		}
		else
		{
			entityTarget = target as IEdmEntityType;
		}
		string navType = navProp.ContainsTarget ? "*" : string.Empty;
		string navCardinality = collectionProp ? "0..*" :  "0..1";
#>
<#=GetTypeName(entity)#> <#=navType#>-- "<#=navCardinality#>" <#=GetTypeName(entityTarget)#>: <#=navProp.Name#> 
<#+
	}
}
#>