<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ assembly name="%USERPROFILE%\.nuget\packages\microsoft.odata.edm\7.7.0\lib\net45\Microsoft.OData.Edm.dll" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="Microsoft.OData.Edm" #>
<#@ import namespace="Microsoft.OData.Edm.Csdl" #>
<#@ import namespace="System.Collections.Generic" #>
<#+
private IEdmModel model;
private string theNamespace;
private string theFilename;

public void EmitPlantDiagram(string csdl, string filename)
{
	this.model = CsdlReader.Parse(XElement.Parse(csdl).CreateReader());
	if (this.model == null)
	{
		this.WriteLine("Failed to parse the CSDL file.");
	}

	this.theNamespace = this.model.DeclaredNamespaces.First();
	this.theFilename = filename;
#>
@startuml
skinparam classAttributeIconSize 0
title API Entity Diagram for namespace <#= this.theNamespace #> in <#= this.theFilename #>


<#+
	this.EmitEntityContainer();
	this.WriteLine("");

	// Collate the bound actions and functions against their bound elememts.
	var boundOperations = new Dictionary<IEdmStructuredType, IList<IEdmOperation>>();
	foreach (IEdmOperation operation in model.SchemaElements.OfType<IEdmOperation>().Where(o => o.IsBound))
	{
		// By spec definition, first parameter is the binding parameter.
		var bindingParameterType = (operation?.Parameters?.FirstOrDefault()?.Type?.Definition) as IEdmStructuredType;
		if (bindingParameterType != null)
		{
			if(!boundOperations.TryGetValue(bindingParameterType, out IList<IEdmOperation> list))
			{
				list = new List<IEdmOperation>();
				boundOperations[bindingParameterType] = list;
			}

			list.Add(operation);
		}
	}

	foreach (IEdmEntityType entity in model.SchemaElements.OfType<IEdmEntityType>())
	{
		this.EmitStructuralType(entity, "entity", boundOperations);
		this.EmitNavigationProperties(entity);
		this.WriteLine("");
	}

	foreach (IEdmComplexType complex in model.SchemaElements.OfType<IEdmComplexType>())
	{
		this.EmitStructuralType(complex, "complexType", boundOperations);
		this.WriteLine("");
	}

	foreach (IEdmEnumType enumeration in model.SchemaElements.OfType<IEdmEnumType>())
	{
		this.EmitEnumType(enumeration);
		this.WriteLine("");
	}

}

private string GetTypeName(IEdmTypeReference theType)
{
	var name = ExtensionMethods.ShortQualifiedName(theType);
	if (name == null)
	{
		// Collections don't produce a SQN.
		name = ExtensionMethods.FullName(theType);
	}

	if (name.Contains(this.theNamespace))
	{
		name = name.Replace(this.theNamespace + ".", string.Empty);
	}
	return name;
}

private string StripCollection(string name)
{
	const string collectionPrefix = "Collection(";
	if (name.Contains(collectionPrefix))
	{
		name = name.Replace(collectionPrefix, string.Empty);
		name = name.Substring(0, name.Length -1);
	}
	return name;
}

private string StripNamespace(string name)
{
	return name.Replace(this.theNamespace + ".", string.Empty);
}


private string GetTypeName(IEdmType theType)
{
	var typeName = string.Empty;
	if (theType is IEdmComplexType complex)
	{
		typeName =  complex.Name;
	}
	else if (theType is IEdmEntityType entity)
	{
		typeName =  entity.Name;
	}
	else if (theType is IEdmCollectionType collection)
	{
		typeName =  GetTypeName(collection.ElementType);
	}
	else if (theType is IEdmEnumType enumeration)
	{
		typeName =  enumeration.Name;
	}

	return StripNamespace(typeName);
}

private string GetTypeColor(IEdmType theType)
{
	if (theType is IEdmComplexType complex)
	{
		return "#Skyblue";
	}
	else if (theType is IEdmEntityType entity)
	{
		return "#PaleGreen";
	}
	return string.Empty;
}

private IEdmType GetFundamentalType(IEdmType theType)
{
	if (theType is IEdmCollectionType collection)
	{
		theType =  collection.ElementType.Definition;
	}
	return theType;
}

private void EmitStructuralType(
	IEdmStructuredType theType,
	string prototype,
	IDictionary<IEdmStructuredType, IList<IEdmOperation>> boundOperations)
{
	List<string> props = new List<string>();
	List<string> complexUsages = new List<string>();
	if (theType is IEdmEntityType && theType.BaseType == null)
	{
		// Add fake id property because everything is originally derived from Graph's 'Entity' base type which would clutter the diagram.
		props.Add("+id: String");
	}

	foreach (IEdmStructuralProperty structProp in theType.DeclaredProperties.OfType<IEdmStructuralProperty>())
	{
		var typeName = this.GetTypeName(structProp.Type);

		// Prefix properties with parentheses in them to avoid them being interpreted as methods.
		string prefix = string.Empty;
		bool collection = false;

		if (typeName.Contains("("))
		{
			prefix = "{field} ";
			collection = true;
		}

		string optionality = string.Empty;
		string cardinalityMin = "1";
		string cardinalityMax = collection ? "*" : "1";
		if (structProp.Type.IsNullable)
		{
			// Cardinality only specified on property names if they are optional.
			cardinalityMin = "0";
			optionality = $" [{cardinalityMin}..{cardinalityMax}]";
		}

		props.Add($"{prefix}+{structProp.Name}: {typeName}{optionality}");
		IEdmType propFundamental = GetFundamentalType(structProp.Type.Definition);
		if (propFundamental.TypeKind == EdmTypeKind.Complex ||
			propFundamental.TypeKind == EdmTypeKind.Enum)
		{
			string basePropType = StripCollection(typeName);
			complexUsages.Add($@"{this.GetTypeName(theType)} +--> ""[{cardinalityMin}..{cardinalityMax}]"" {basePropType}: {structProp.Name}");
		}
	}
	var isAbstract = theType.IsAbstract ? "abstract " : string.Empty;
	if (prototype.Equals("entity") && !theType.IsAbstract)
	{
		prototype = $"(N,white){prototype}";
	}

	string extends = string.Empty;
	if (theType.BaseType != null)
	{
		extends = $" extends {GetTypeName(theType.BaseType as IEdmStructuredType)}";
	}
#>
<#= isAbstract #>class <#=this.GetTypeName(theType)#> <<<#=prototype#>>> <#=this.GetTypeColor(theType)#><#=extends#> {
<#+
	foreach (var prop in props)
	{
		WriteLine(prop);
	}
	if(boundOperations.TryGetValue(theType, out IList<IEdmOperation> list))
	{
		foreach (var boundOperation in list)
		{
			WriteLine($"+{boundOperation.Name}()");
		}
	}
#>
}
<#+
	foreach ( var usage in complexUsages) { WriteLine(usage); }
}

private void EmitActions()
{
}

private void EmitEntityContainer()
{
	if (this.model.EntityContainer == null)
	{
		return;
	}

	List<string> members = new List<string>();
	foreach (IEdmSingleton singleton in this.model.EntityContainer.Elements.OfType<IEdmSingleton>())
	{
		var singletonTypeName = GetTypeName(singleton.Type);
		members.Add($"+{singleton.Name}: {singletonTypeName}");
#>
<#=this.model.EntityContainer.Name#> .. "1..1" <#=singletonTypeName#>: <#=singleton.Name#>
<#+
	}

	foreach (IEdmEntitySet entitySet in this.model.EntityContainer.Elements.OfType<IEdmEntitySet>())
	{
		var entitySetTypeName = GetTypeName(entitySet.EntityType());
		members.Add($"+{entitySet.Name}: {entitySetTypeName}");
#>
<#=this.model.EntityContainer.Name#> .. "0..*" <#=StripCollection(entitySetTypeName)#>: <#=entitySet.Name#>
<#+
	}
#>
class <#=this.model.EntityContainer.Name#> <<(S,white)entityContainer>> #LightPink {
<#+ foreach ( var member in members) { WriteLine(member); }#>
}
<#+
}

private void EmitEnumType(IEdmEnumType theType)
{
#>
enum <#=this.GetTypeName(theType)#> <<enum>> #GoldenRod {
<#+ foreach (IEdmEnumMember member in theType.Members) { WriteLine($"{member.Name}"); }#>
}
<#+
}

private void EmitNavigationProperties(IEdmEntityType entity)
{
	foreach (IEdmNavigationProperty navProp in entity.DeclaredProperties.OfType<IEdmNavigationProperty>())
	{
		var target = (navProp.Type as IEdmTypeReference).Definition;
		IEdmEntityType entityTarget;
		var collectionProp = false;
		if (target is IEdmCollectionType coll)
		{
			entityTarget = (coll.ElementType as IEdmTypeReference).Definition as IEdmEntityType;
			collectionProp = true;
		}
		else
		{
			entityTarget = target as IEdmEntityType;
		}
		string navType = navProp.ContainsTarget ? "*" : string.Empty;
		string navCardinality = collectionProp ? "0..*" :  "0..1";
#>
<#=GetTypeName(entity)#> <#=navType#>--> "<#=navCardinality#>" <#=GetTypeName(entityTarget)#>: <#=navProp.Name#> 
<#+
	}
}
#>